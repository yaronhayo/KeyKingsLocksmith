---
// Newsletter subscription form
export interface Props {
  class?: string;
  variant?: 'inline' | 'stacked';
  placeholder?: string;
}

const {
  class: className = '',
  variant = 'inline',
  placeholder = 'Enter your email',
} = Astro.props;
---

<div class={`newsletter-form-container ${className}`}>
  <form id="newsletter-form" class={variant === 'inline' ? 'flex gap-2' : 'space-y-3'}>
    <div class="flex-1">
      <label for="newsletter-email" class="sr-only">Email address</label>
      <input
        type="email"
        id="newsletter-email"
        name="email"
        required
        class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
        placeholder={placeholder}
      />
      <div class="error-message hidden text-red-600 text-sm mt-1"></div>
    </div>

    <button
      type="submit"
      class="newsletter-submit-btn px-6 py-3 bg-primary-600 text-white font-semibold rounded-lg hover:bg-primary-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed whitespace-nowrap"
    >
      <span class="btn-text">Subscribe</span>
      <span class="btn-loading hidden">...</span>
    </button>
  </form>

  <!-- Success Message -->
  <div id="newsletter-success" class="hidden mt-3 p-3 bg-green-50 border border-green-200 rounded-lg text-green-800 text-sm">
    âœ“ Successfully subscribed! Check your email for confirmation.
  </div>

  <!-- Error Message -->
  <div id="newsletter-error" class="hidden mt-3 p-3 bg-red-50 border border-red-200 rounded-lg text-red-800 text-sm"></div>
</div>

<script>
  import { subscribeNewsletter, validateForm, handleFormError, trackFormSuccess } from '../../lib/api/client';

  document.addEventListener('DOMContentLoaded', () => {
    const form = document.getElementById('newsletter-form') as HTMLFormElement;
    if (!form) return;

    const input = form.querySelector('#newsletter-email') as HTMLInputElement;
    const submitBtn = form.querySelector('.newsletter-submit-btn') as HTMLButtonElement;
    const btnText = submitBtn?.querySelector('.btn-text');
    const btnLoading = submitBtn?.querySelector('.btn-loading');
    const successMessage = document.getElementById('newsletter-success');
    const errorMessage = document.getElementById('newsletter-error');
    const fieldError = form.querySelector('.error-message');

    form.addEventListener('submit', async (e) => {
      e.preventDefault();

      // Clear previous messages
      fieldError?.classList.add('hidden');
      successMessage?.classList.add('hidden');
      errorMessage?.classList.add('hidden');
      input?.classList.remove('border-red-500');

      const email = input.value.trim();

      // Validate email
      const validationError = validateForm.email(email);
      if (validationError && fieldError) {
        fieldError.textContent = validationError;
        fieldError.classList.remove('hidden');
        input?.classList.add('border-red-500');
        return;
      }

      // Show loading
      if (submitBtn && btnText && btnLoading) {
        submitBtn.disabled = true;
        btnText.classList.add('hidden');
        btnLoading.classList.remove('hidden');
      }

      try {
        const response = await subscribeNewsletter(email);

        if (response.success) {
          successMessage?.classList.remove('hidden');
          form.reset();
          trackFormSuccess('newsletter');
        } else {
          throw new Error(response.error?.message || 'Subscription failed');
        }
      } catch (error) {
        const errorMsg = handleFormError(error);
        if (errorMessage) {
          errorMessage.textContent = errorMsg;
          errorMessage.classList.remove('hidden');
        }
      } finally {
        if (submitBtn && btnText && btnLoading) {
          submitBtn.disabled = false;
          btnText.classList.remove('hidden');
          btnLoading.classList.add('hidden');
        }
      }
    });
  });
</script>
