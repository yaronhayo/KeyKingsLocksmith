---
// Newsletter subscription form
export interface Props {
  class?: string;
  variant?: 'inline' | 'stacked';
  placeholder?: string;
}

const {
  class: className = '',
  variant = 'inline',
  placeholder = 'Enter your email',
} = Astro.props;
---

<div class={`newsletter-form-container ${className}`}>
  <form id="newsletter-form" class={variant === 'inline' ? 'flex gap-2' : 'space-y-3'}>
    <div class="flex-1">
      <label for="newsletter-email" class="sr-only">Email address</label>
      <input
        type="email"
        id="newsletter-email"
        name="email"
        required
        class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
        placeholder={placeholder}
      />
      <div class="error-message hidden text-orange-600 text-sm mt-1"></div>
    </div>

    <button
      type="submit"
      class="newsletter-submit-btn px-6 py-3 bg-primary-600 text-white font-semibold rounded-lg hover:bg-primary-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed whitespace-nowrap"
    >
      <span class="btn-text">Subscribe</span>
      <span class="btn-loading hidden">...</span>
    </button>
  </form>

  <!-- Success Message -->
  <div id="newsletter-success" class="hidden mt-3 p-3 bg-green-50 border border-green-200 rounded-lg text-green-800 text-sm">
    âœ“ Successfully subscribed! Check your email for confirmation.
  </div>

  <!-- Error Message -->
  <div id="newsletter-error" class="hidden mt-3 p-3 bg-orange-50 border border-orange-200 rounded-lg text-orange-800 text-sm"></div>
</div>

<script>
  // Lazy load form logic only when user interacts
  let formInitialized = false;
  const recaptchaSiteKey = import.meta.env.GOOGLE_RECAPTCHA_SITE_KEY || import.meta.env.PUBLIC_GOOGLE_RECAPTCHA_SITE_KEY;

  // Load reCAPTCHA lazily on first interaction
  let recaptchaLoaded = false;
  const loadRecaptcha = () => {
    if (recaptchaLoaded || !recaptchaSiteKey) return;
    recaptchaLoaded = true;

    // Hide the default reCAPTCHA badge
    const style = document.createElement('style');
    style.textContent = '.grecaptcha-badge { visibility: hidden !important; }';
    document.head.appendChild(style);

    const script = document.createElement('script');
    script.src = `https://www.google.com/recaptcha/api.js?render=${recaptchaSiteKey}`;
    script.async = true;
    script.defer = true;
    document.head.appendChild(script);
  };

  // Initialize form on first interaction
  const initializeForm = async () => {
    if (formInitialized) return;
    formInitialized = true;

    // Dynamically import heavy validation logic
    const { subscribeNewsletter, validateForm, handleFormError, trackFormSuccess } = await import('../../lib/api/client');

    // Load reCAPTCHA when form is used
    loadRecaptcha();
    const form = document.getElementById('newsletter-form') as HTMLFormElement;
    if (!form) return;

    const input = form.querySelector('#newsletter-email') as HTMLInputElement;
    const submitBtn = form.querySelector('.newsletter-submit-btn') as HTMLButtonElement;
    const btnText = submitBtn?.querySelector('.btn-text');
    const btnLoading = submitBtn?.querySelector('.btn-loading');
    const successMessage = document.getElementById('newsletter-success');
    const errorMessage = document.getElementById('newsletter-error');
    const fieldError = form.querySelector('.error-message');

    form.addEventListener('submit', async (e) => {
      e.preventDefault();

      // Clear previous messages
      fieldError?.classList.add('hidden');
      successMessage?.classList.add('hidden');
      errorMessage?.classList.add('hidden');
      input?.classList.remove('border-orange-500');

      const email = input.value.trim();

      // Validate email
      const validationError = validateForm.email(email);
      if (validationError && fieldError) {
        fieldError.textContent = validationError;
        fieldError.classList.remove('hidden');
        input?.classList.add('border-orange-500');
        return;
      }

      // Show loading
      if (submitBtn && btnText && btnLoading) {
        submitBtn.disabled = true;
        btnText.classList.add('hidden');
        btnLoading.classList.remove('hidden');
      }

      try {
        // Get reCAPTCHA token (if available)
        let recaptchaToken: string | undefined;
        if (recaptchaSiteKey && typeof (window as any).grecaptcha !== 'undefined') {
          try {
            recaptchaToken = await (window as any).grecaptcha.execute(recaptchaSiteKey, { action: 'newsletter' });
          } catch (error) {
            console.error('reCAPTCHA error:', error);
          }
        }

        const response = await subscribeNewsletter(email);

        if (response.success) {
          successMessage?.classList.remove('hidden');
          form.reset();
          trackFormSuccess('newsletter');
        } else {
          throw new Error(response.error?.message || 'Subscription failed');
        }
      } catch (error) {
        const errorMsg = handleFormError(error);
        if (errorMessage) {
          errorMessage.textContent = errorMsg;
          errorMessage.classList.remove('hidden');
        }
      } finally {
        if (submitBtn && btnText && btnLoading) {
          submitBtn.disabled = false;
          btnText.classList.remove('hidden');
          btnLoading.classList.add('hidden');
        }
      }
    });
  };

  // Set up lazy initialization
  document.addEventListener('DOMContentLoaded', () => {
    const form = document.getElementById('newsletter-form') as HTMLFormElement;
    if (!form) return;

    // Initialize on first focus of any form field
    const initOnFocus = () => {
      initializeForm();
      form.removeEventListener('focusin', initOnFocus);
    };

    form.addEventListener('focusin', initOnFocus, { once: true, passive: true });
  });
</script>
